# Info Class

用于代替 `data class` 的功能，通过 **Kotlin Compiler Plugin** 在编译时为类生成 `equals`, `hashCode`, `toString`, `copy`, `componentN` 方法。



#### data class

通过 **data class** 生成的 `equals, hashCode, toString, copy, componentN ` 方法具有以下缺点：

- 必须将需要生成的属性写到主构造函数中，这会导致非常的多的问题，实际上有很多特殊属性（**delegate**, **lateinit**, **lazy**, 和其他...）我们都可能想参与某些生成方法中，但只能完全覆盖并重写一遍对应的方法（如 `equals`），这样将直接丢失 **data class** 的优势
- 无法细分控制哪些是属性是不需要参与 `equals, hashCode, toString, copy, componentN` 的生成的
- 数组类型的属性完全失去生成的 `equals` 作用，因为根本没有进行正确的判断，需要完全手动复写一次 `equals` 方法
- 数据类不能与 **inner class** 一起声明
- 数据类是 **final** 的，既不能被继承

> 很多时候让我很抓狂的点在于一旦出现任何达不到需求的因素就需要完全重写整个方法，容易出错不说，还常常要写一堆样板代码（屎山）！！！

------

### @Info 注解

```kotlin
@Target(AnnotationTarget.CLASS)
annotation class Info(
  val generateCopy: Boolean = true,
  val generateEquals: Boolean = true,
  val generateHashCode: Boolean = true,
  val generateToString: Boolean = true,
  val generateComponentN: Boolean = true,
  val joinPrivateProperties: Boolean = false,
  val joinPrimaryProperties: Boolean = true,
  val joinProperties: Boolean = true,
  val callSuperEquals: Boolean = true,
  val callSuperHashCode: Boolean = true,
)
```

通过注解在编译时插入代码可以达到 Kotlin `data class` 的替代实现，`@Info` 注解是用来识别 **info class** 的唯一标准。

#### 子注解：

- **@Invisible 注解**

  ```kotlin
  @Target(AnnotationTarget.PROPERTY)
  annotation class Invisible(
    val generateCopy: Boolean = false, // 此值对主构造函数中声明的属性无效（因为 copy(..) 需要通过主构造函数创建对象）
    val generateEquals: Boolean = false,
    val generateHashCode: Boolean = false,
    val generateToString: Boolean = false,
    val generateComponentN: Boolean = false,
  )
  ```
  
  应用于属性的注解，参数为 **false** 则表示注解不会参与到对应方法的代码生成中，**true** 反之。比如只有 `toString = true`, 则生成的方法中只有 `toString()` 方法才会包含此属性。

------

#### 声明：

```kotlin
@Info
class User(
  root: Boolean,
  @Info.Invisible val id: Int,
  /** @Info.Invisible */ private val decoder: UserDecoder,
) {
  @LazyInit val name: String = decoder.readName()
  
  lateinit var address: IntArray
  
  val age: Int get() = decoder.readAge()
  
  val email: String by decoder.email
  
  suspend fun queryAge() {
    request(UserUrl, "age" to true) { result ->
      age = result
    }
  }
  
  /** Overridden functions are not generate again */ 
  override fun equals(other: Any?): Boolean = !isExpired(id) && infoEquals(other)
  override fun hashCode(): Int = 0
}
```

- **优点**
  
  1. 可细粒度控制需要参与生成的属性（默认 `private` 的属性都不会参与生成）
  2. 支持非主函数的 `val/var` 甚至是 `lateinit`, `getter`, `delegate`, `vararg` 属性
  3. 数组类型具有正确的对比表达式: `array.contentEquals(other)`
  4. 支持继承部分生成的方法（`infoEquals`, `infoHashCode`, `infoToString`），这三个方法会在类注解 **@Info** 的那一刻可用
  5. 拥有 Kotlin **data class** 的所有优点
- **限制**

  1. 当 **@Info class** 声明了多个构造函数时，必须明确声明主构造函数，用作 **copy** 方法的对象创建

  2. 类中声明的属性不能与**主构造函数/唯一构造函数**中的参数的名称相同，以避免 **copy** 方法中的参数冲突

     ```Kotlin
     class Foo {
       constructor(a: String)
       private val a: Int // ERROR
     }
     ```

     

#### 幕后生成代码（伪反编译）：

```kotlin
override fun equals(other: Any?): Boolean = !isExpired(id) && infoEquals(other) /** ❶ infoEquals(other) */

// Generated by kotlin compiler
private final fun infoEquals(other: Any?): Boolean {
  if (!super.equals(other)) return false
  if (this === other) return true
  if (other !is User) return false
  
  return name == other.name 
    && address.contentEquals(other.address) 
    && age == other.age 
    && email == other.email
}

override fun toString(): String =
  "User(name=$name, address=${address.contentToString()}, age=$age, email=$email)"

/** ❷ */
operator fun component1(): String = name
operator fun component2(): IntArray = address
operator fun component3(): Int = age
operator fun component4(): String = email

/** ❸ */
fun copy(
  root: Boolean, // Required parameter of constructor
  id: Int = this.id,
  decoder: UserDecoder = this.decoder,
  address: IntArray = this.address,
): User = User(id, decoder).also {
  it.address = address
}
```

> **注：**
>
> - ❶  在 IDE 与编译器检查文件树时会自动为注解了 @Info 的类继承一个 **Info.Synthetic** 接口，接口里面包含 `infoEquals, infoHashCode, infoToString` 的占坑方法，这些占坑方法会在编译时自动实现
> - ❷  按照类中声明的属性的顺序创建 **componentN** 函数
> - ❸   按照类中声明的属性的顺序创建 **copy** 函数，参数列表的开头会包含主构造函数中声明的属性，即使主构造函数中的属性注解了 **@Info.Invisible**，因为他们需要用于创建对象

