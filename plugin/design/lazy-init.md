# LazyInit

用于代替 `by lazy` 和 `lateinit` 的轻量级功能，通过 **Kotlin Compiler Plugin** 在编译时生成延迟初始化的代码。



#### by lazy 对象委托

通过 **Kotlin 委托** 形式实现的延迟属性拥有以下缺点：

- 需要一个 `Lazy` 对象作为后端储存，这种方式需要占用非常多的内存，得不偿失。
- **Kotlin Stdlib** 默认的 `Lazy` 只能访问不可修改，即使创建了 `MutableLazy`，想重置 `value` 时还需要创建额外的属性来委托，不够优雅。



#### lateinit 修饰符

通过修饰符形式实现的延迟属性拥有以下缺点：

- 需要在以后的某处手动设置属性的值，这种分开声明导致了很多不确定性，比如调用的时机比初始化早，甚至是忘记初始化。
- 不支持基本类型，Kotlin 限制这个的根本原因是 **lateinit** 幕后需要一个 `null` 值, 而如果基本类型为 null 则会导致装箱（**Int -> Integer**）。

------

#### 声明：

```kotlin
val int: Int by lazy { 100 }
var instance: Any by lazy { Foo() }
lateinit var foo: String
```

#### 幕后（伪反编译）：

```kotlin
// Under the hood for delegate
class LazyImpl(initializer: () -> Any) {
  var _value: Any? = null
  val value: Any get() = _value ?: initializer().also { _value = it }
}

// Generated by kotlin compiler
val int$delegate: Lazy = LazyImpl(object : kotlin.Function<Int> {
  fun invoke() = 100
})

val int: Int
  get() = int$delegate.getValue()

// Generated by kotlin compiler
val int$instance: Lazy = LazyImpl(object : kotlin.Function<Any> {
  fun invoke() = Foo()
})

val instance: Any
  get() = int$instance.getValue()

var foo: String = null
```

> 可以看出仅仅一个基本类型 **int** 就创建了两个对象，并且这个 **int** 是装箱的，编译后既 **java** 的 **Integer**，比基本类型将占用更多内存。



### @LazyInit 注解

通过注解在编译时修改代码可以达到轻量级的 Kotlin `lazy` 替代实现，`@LazyInit` 注解是用来识别延迟初始化属性的唯一标准。

------

#### 声明：

```kotlin
@LazyInit
var int: Int = 100

@LazyInit
val instance: Any = Foo()
```

- **优点**
  1. 只需要一个 `LazyInit` 注解，具有与正常变量一致的简洁声明
  2. 超低的内存占用
  3. 可以随时重新设置 lazy 值 
- **限制**
  1. 属性不能声明 **getter**
  2. 属性必须存在 **initializer** (既初始化值 `val x = ???`)，此值将用于后续的延迟初始化
  3. 属性不可以使用 **@JvmField** 注解

#### 幕后（伪反编译）：

```kotlin
// Generated by kotlin compiler
var _isInit$int = false

@LazyInit 
var int: Int /* = null */
  // Generated by kotlin compiler (not null)
  get() = when {
    _isInit$int -> field
    else -> 100.also {
      field = it
      _isInit$int = true
    }
  }

// Generated by kotlin compiler
var _isInit$instance = false

@LazyInit
var instance: Any /* = null */
  // Generated by kotlin compiler (not null)
  get() = when {
    _isInit$instance -> field
    else -> Foo().also {
      field = it
      _isInit$instance = true
    }
  }
  private set // keep val
```

> 根据注解声明的属性生成生成额外的状态值：
>
> - **_isInit$xx** 用来判断属性是否已经被初始化
>
> 属性将会生成一个拥有 **when 表达式 **的 **getter**，第一次调用时将使用预先定义的值，然后将这个值设置到 **backingField** 以储存，并且将标记 `_isInit$xx` 设置为 **true**，这样在下一次调用属性时就会改为直接调用 **backingField** 了。

## 重置

既然支持 '**settable**'，那么同样，`@LazyInit` 属性也应该支持重置属性

提供两个函数，`Any` 只能是带有 `LazyInit` 注解的属性，如果不是一个属性或者属性没有预期的注解则编译器插件报告错误。

```kotlin
fun Any.resetLazyValue()
fun resetLazyValues(vararg lazyProperties: Any)
```

#### 示例：

```Kotlin
@LazyInit var foo: Array<String> = arrayOf("A", "B")
@LazyInit var bar: String = "One"
@LazyInit var baz: String = "Two"

fun main() {
  println(foo) // [A, B]
  println(bar) // "One
  println(baz) // "Two"
  
  foo = emptyArray()
  bar = "??"
  baz = "OK"
  println(foo) // []
  println(bar) // "??"
  println(baz) // "OK"
  
  foo.resetLazyValue()
  resetLazyValues(bar, baz)
  println(foo) // [A, B]
  println(bar) // "One
  println(baz) // "Two"
}
```

#### 幕后（伪反编译）：

```Kotlin
var _isInit$foo = false
var _isInit$bar = false
var _isInit$baz = false

@LazyInit var foo: Array<String> = null
@LazyInit var bar: String = null
@LazyInit var baz: String = null

fun getFoo() = when {
  _isInit$foo -> foo
  else -> arrayOf("A", "B").also {
    foo = it
    _isInit$foo = true
  }
}
fun getBar() = when {
  _isInit$bar -> bar
  else -> "One".also {
    bar = it
    _isInit$bar = true
  }
}
fun getBaz() = when {
  _isInit$baz -> baz
  else -> "Two".also {
    baz = it
    _isInit$baz = true
  }
}

fun main() {
  println(getFoo()) 
  println(getBar()) 
  println(getBaz()) 
  
  foo = emptyArray()
  bar = "??"
  baz = "OK"
  println(getFoo())
  println(getBar())
  println(getBaz())
  
  foo = null // foo.resetLazyValue()
  bar = null // resetLazyValues(bar, ...)
  baz = null // resetLazyValues(..., baz)
  
  println(getFoo())
  println(getBar())
  println(getBaz())
}
```



