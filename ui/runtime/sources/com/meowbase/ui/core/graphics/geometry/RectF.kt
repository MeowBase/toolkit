package com.meowbase.ui.core.graphics.geometry

import android.graphics.RectF
import com.meowbase.toolkit.float
import com.meowbase.toolkit.lerp
import kotlin.math.max
import kotlin.math.min


/**
 * The lesser of the magnitudes of the [RectF.width] and the [RectF.height].
 */
val RectF.minSize: Float
  get() = min(width(), height())

/**
 * The greater of the magnitudes of the [RectF.width] and the [RectF.height].
 */
val RectF.maxSize: Float
  get() = max(width(), height())


fun RectF.toSize(): Size = Size(width(), height())

/**
 * Construct a rectangle from its left and top edges as well as its width and height.
 * @param offset Offset to represent the top and left parameters of the RectF
 * @param size Size to determine the width and height of this [RectF].
 * @return RectF with [RectF.left] and [RectF.top] configured to [Offset.x] and [Offset.y] as
 * [RectF.right] and [RectF.bottom] to [Offset.x] + [Size.width] and [Offset.y] + [Size.height]
 * respectively
 */
fun RectF(offset: Offset, size: Size): RectF =
  RectF(
    offset.x,
    offset.y,
    offset.x + size.width,
    offset.y + size.height
  )

/**
 * Construct the smallest rectangle that encloses the given offsets, treating
 * them as vectors from the origin.
 * @param topLeft Offset representing the left and top edges of the rectangle
 * @param bottomRight Offset representing the bottom and right edges of the rectangle
 */
fun RectF(topLeft: Offset, bottomRight: Offset): RectF =
  RectF(
    topLeft.x,
    topLeft.y,
    bottomRight.x,
    bottomRight.y
  )

/**
 * Construct a rectangle that bounds the given circle
 * @param center Offset that represents the center of the circle
 * @param radius Radius of the circle to enclose
 */
fun RectF(center: Offset, radius: Float): RectF =
  RectF(
    center.x - radius,
    center.y - radius,
    center.x + radius,
    center.y + radius
  )

/**
 * Linearly interpolate between two rectangles.
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 *
 * Values for [fraction] are usually obtained from an [Animation<Float>], such as
 * an `AnimationController`.
 */
fun lerp(start: RectF, stop: RectF, fraction: Float): RectF {
  return RectF(
    lerp(start.left, stop.left, fraction),
    lerp(start.top, stop.top, fraction),
    lerp(start.right, stop.right, fraction),
    lerp(start.bottom, stop.bottom, fraction)
  )
}

fun RectF(left: Number, top: Number, right: Number, bottom: Number): RectF =
  RectF(left.float, top.float, right.float, bottom.float)