package com.meowbase.ui.core.graphics.geometry

import android.graphics.Rect
import com.meowbase.toolkit.float
import com.meowbase.toolkit.int
import com.meowbase.toolkit.lerp
import kotlin.math.max
import kotlin.math.min
import kotlin.math.roundToInt

/**
 * The lesser of the magnitudes of the [Rect.width] and the [Rect.height].
 */
val Rect.minSize: Int
  get() = min(width(), height())

/**
 * The greater of the magnitudes of the [Rect.width] and the [Rect.height].
 */
val Rect.maxSize: Int
  get() = max(width(), height())

fun Rect.toSize(): Size = Size(width(), height())

/**
 * Construct a rectangle from its left and top edges as well as its width and height.
 * @param offset Offset to represent the top and left parameters of the Rect
 * @param size Size to determine the width and height of this [Rect].
 * @return Rect with [Rect.left] and [Rect.top] configured to [Offset.x] and [Offset.y] as
 * [Rect.right] and [Rect.bottom] to [Offset.x] + [Size.width] and [Offset.y] + [Size.height]
 * respectively
 */
fun Rect(offset: Offset, size: Size): Rect =
  Rect(
    offset.x.int,
    offset.y.int,
    (offset.x + size.width).roundToInt(),
    (offset.y + size.height).roundToInt(),
  )

/**
 * Construct the smallest rectangle that encloses the given offsets, treating
 * them as vectors from the origin.
 * @param topLeft Offset representing the left and top edges of the rectangle
 * @param bottomRight Offset representing the bottom and right edges of the rectangle
 */
fun Rect(topLeft: Offset, bottomRight: Offset): Rect =
  Rect(
    topLeft.x.int,
    topLeft.y.int,
    bottomRight.x.int,
    bottomRight.y.int,
  )

/**
 * Construct a rectangle that bounds the given circle
 * @param center Offset that represents the center of the circle
 * @param radius Radius of the circle to enclose
 */
fun Rect(center: Offset, radius: Float): Rect =
  Rect(
    (center.x - radius).roundToInt(),
    (center.y - radius).roundToInt(),
    (center.x + radius).roundToInt(),
    (center.y + radius).roundToInt()
  )

/**
 * Linearly interpolate between two rectangles.
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 *
 * Values for [fraction] are usually obtained from an [Animation<Float>], such as
 * an `AnimationController`.
 */
fun lerp(start: Rect, stop: Rect, fraction: Float): Rect {
  return Rect(
    lerp(start.left, stop.left, fraction),
    lerp(start.top, stop.top, fraction),
    lerp(start.right, stop.right, fraction),
    lerp(start.bottom, stop.bottom, fraction)
  )
}

fun Rect(left: Number, top: Number, right: Number, bottom: Number): Rect =
  Rect(left.float, top.float, right.float, bottom.float)